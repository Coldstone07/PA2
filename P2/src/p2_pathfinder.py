from heapq import heappop, heappushimport mathdef find_path (source_point, destination_point, mesh):    sourceBox = None    destinationBox = None    for box in mesh["boxes"]:        x1, x2, y1, y2 = box        sx, sy = source_point        dx, dy = destination_point        if x1 <= sx < x2 and y1 <= sy < y2:            print("found source")            sourceBox = box        if x1 <= dx < x2 and y1 <= dy < y2:            print("found destination")            destinationBox = box    path = []    boxes = {}    #bfs    queue = []    parent = dict()    heappush(queue, sourceBox)    parent[sourceBox] = None    while queue:        current_box = queue.pop()        print(current_box)        if current_box is destinationBox:            current = destinationBox            while current:                boxes[current] = parent[current]                current = parent[current]            break        else:            for adj in mesh["adj"][current_box]:                print("adjacent box:", adj)                if adj not in parent:                    queue.append(adj)                    parent[adj] = current_box    print("source point:", source_point)    print("destination point: ", destination_point)    print('found solution: ', boxes)    #path points and distance calc    points = {destination_point: None}    distance = {}    curr = destination_point    for box in boxes:        if boxes[box] is None:            # we are at the origin            break        next_box = boxes[box]        dx1, dx2, dy1, dy2 = next_box        cx1, cx2, cy1, cy2 = box        line = []  # (x1, x2, y1, y2)        if cx1 == dx2:  # top            if (dy2 - dy1) < (cy2 - cy1):  # destination is smaller                line = [dx2, dx2, dy1, dy2]            else:  # current is smaller                line = [cx1, cx1, cy1, cy2]        elif cy1 == dy2:  # left            if (dx2 - dx1) < (cx2 - cx1):  # destination is smaller                line = [dx1,  dx2, dy2, dy2]            else:  # current is smaller                line = [cx1, cx2, cy1, cy1]        elif cx2 == dx1:  # bottom            if (dy2 - dy1) < (cy2 - cy1):  # destination is smaller                line = [dx1, dx1, dy1, dy2]            else:  # current is smaller                line = [cx2, cx2, cy1, cy2]        elif cy2 == dy1:  # right            if (dx2 - dx1) < (cx2 - cx1): # destination is smaller                line = [dx1, dx2, dy1, dy1]            else:  # current is smaller                line = [cx1, cx2, cy2, cy2]                # print(line)        # calculate the line to L, R and mid        left_most = (line[0], line[2])        right_most = (line[1], line[3])        on_point = ()        if right_most[0] - left_most[0] == 0: # x2 - x1 , horizontal            if curr[1] < left_most[1]: # y < y1                on_point = left_most            elif curr[1] > right_most[1]:                on_point = right_most            else:                on_point = (right_most[0], curr[1])        else:            if curr[0] < left_most[0]: # x < x1                on_point = left_most            elif curr[0] > right_most[0]:                on_point = right_most            else:                on_point = (curr[0], right_most[1])        points[box] = on_point        print(curr, on_point)        dist = math.sqrt((curr[0] - on_point[0])**2 + (curr[1] - on_point[1])**2)  # calculates the distance        distance[box] = dist        print(dist)        curr # x,y coord in current box    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    return path, boxes.keys()