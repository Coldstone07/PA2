from heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    sourceBox = None    destinationBox = None    for box in mesh["boxes"]:        x1, x2, y1, y2 = box        sx, sy = source_point        dx, dy = destination_point        if x1 <= sx < x2 and y1 <= sy < y2:            print("found source")            sourceBox = box        if x1 <= dx < x2 and y1 <= dy < y2:            print("found destination")            destinationBox = box    path = []    boxes = {}    #bfs    queue = []    parent = dict()    heappush(queue, sourceBox)    parent[sourceBox] = None    while queue:        current_box = queue.pop()        print(current_box)        if current_box is destinationBox:            current = destinationBox            while current:                boxes[current] = parent[current]                current = parent[current]            break        else:            for adj in mesh["adj"][current_box]:                print("adjacent box:", adj)                if adj not in parent:                    queue.append(adj)                    parent[adj] = current_box    print("source point:", source_point)    print("destination point: ", destination_point)    print('found solution: ', boxes)    #path points and distance calc    points = {destination_point: None}    curr = destination_point    for box in boxes:        if boxes[box] is None:            # we are at the origin            break        next_box = boxes[box]        dx1, dx2, dy1, dy2 = next_box        cx1, cx2, cy1, cy2 = box        line = []  # (x1, x2, y1, y2)        if cx1 == dx2:  # top            if (dy2 - dy1) < (cy2 - cy1):  # destination is smaller                line = [dx2, dx2, dy1, dy2]            else:  # current is smaller                line = [cx1, cx1, cy1, cy2]        elif cy1 == dy2:  # left            if (dx2 - dx1) < (cx2 - cx1):  # destination is smaller                line = [dx1,  dx2, dy2, dy2]            else:  # current is smaller                line = [cx1, cx2, cy1, cy1]        elif cx2 == dx1:  # bottom            if (dy2 - dy1) < (cy2 - cy1):  # destination is smaller                line = [dx1, dx1, dy1, dy2]            else:  # current is smaller                line = [cx2, cx2, cy1, cy2]        elif cy2 == dy1:  # right            if (dx2 - dx1) < (cx2 - cx1): # destination is smaller                line = [dx1, dx2, dy1, dy1]            else:  # current is smaller                line = [cx1, cx2, cy2, cy2]        # calculate the line to L, R and mid    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    return path, boxes.keys()