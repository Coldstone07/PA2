from heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    sourceBox = None    destinationBox = None    for box in mesh["boxes"]:        x1, x2, y1, y2 = box        sx, sy = source_point        dx, dy = destination_point        if x1 <= sx < x2 and y1 <= sy < y2:            print("found source")            sourceBox = box        if x1 <= dx < x2 and y1 <= dy < y2:            print("found destination")            destinationBox = box    path = []    boxes = {}    #bfs    queue = []    parent = dict()    heappush(queue, sourceBox)    parent[sourceBox] = None    while queue:        current_box = queue.pop()        print(current_box)        if current_box is destinationBox:            print("found solution: ")            current = destinationBox            while current:                print(current)                boxes[current] = current                current = parent[current]            break        else:            for adj in mesh["adj"][current_box]:                print("adjacent box:", adj)                if adj not in parent:                    queue.append(adj)                    parent[adj] = current_box    print("source point:", source_point)    print("destination point: ", destination_point)    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    return path, boxes.keys()